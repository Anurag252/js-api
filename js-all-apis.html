<html>
    <body>
<h1>JS Types</h1>
<ul>
    <li>String</li>
    <li>Number</li>
    <li>Symbol <sub> new  to (ES 6)</sub></li>
    <li>Undefined</li>
    <li>Null</li>
    <li>Object</li>
    <li>Boolean</li>
</ul>
<p>typeof null is object. To determine null , use<code> variable === null</code></p>
<div class="codeblock"> 
    <code class="1c">typeof null</code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>

<p>unassigned variable is Undefined</p>
<div class="codeblock"> 
    <code class="1c">var a ; typeof a</code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>
<br/>
<p>if spaces in between properties or <b>it a property is from a variable</b>, then use [] 
</p>
<div class="codeblock"> 
    <code class="1c">var obj = {"b c" : "test"};obj["b c"]</code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>

<br/>
<p>array and functions are objects but type of function is function<sup>Nuance</sup></p>
<div class="codeblock"> 
    <code class="1c">var fun = function(){}; typeof fun</code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>
<br/>
<p>
    List of falsy values<sup>Nuance</sup></p>
    <ul>
        <li>"" <sub>empty string</sub></li>
        <li>0</li>
        <li>-0</li>
        <li>NaN</li>
        <li>Null</li>
        <li>undefined</li>
        <li>false</li>
    </ul>

    <p>When toString is called over array , it prints a csv of elements</p>

   <p> if one of the operand is number and other is NaN , then comparision is always false</p>
   <div class="codeblock"> 
        <code class="1c">(42 > "foo") === (42  &lt; "foo")</code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    </div>
    
    <p>Anonymous function <code>var foo = function(){

    }
    </code></p>
    <p>Named function <code>var foo = function test(){

    }
    </code></p>

    <p>IIFE function <code> (function IIFE(){

    })()
    </code></p>

    <h4>Closure</h4>
    <div class="codeblock"> 
        <code class="1c">function makeaddr(x){
            function add(y){
                return y + x;
            };
            return add;
        }
        var plusone = makeaddr(1);
        var plusTen = makeaddr(10);
        plusone(3);
        plusTen(4);
    </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    </div>

    <h4>Cheating scope</h4>
    <p>
        <ol>
            <li>eval </li>
            <li>new function("")<p>takes in string code and creates new scope</p></li>
            <li>With modifies object and creates a new scope
                <div class="codeblock"> 
                    <code class="1c">
                        function foo(obj)
                        {
                            with (obj)
                            {
                                a = 2;
                            }
                        }
                        var o1 = { a : 3};
                        var o2 = { b : 3};
                        foo(o1)
                        o1.a = 5;

                        foo(o2);
                        a

                     </code>
                    <br/>
                    <code class="1a"></code>
                    <br/>
                    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
                </div>
            </li>
        </ol>
    </p>

<hr/>
<h1>Arrays</h1>
<div class="codeblock"> 
    <code class="1c">
       var arr = [] ;
       arr.push("1");
       arr.push({"a": "test"});
       arr;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<div class="codeblock"> 
    <code class="1c">
        var arr = [] ;
        arr.push("1");
        arr.push({"a": "test"});
        arr.push(3);
        arr.splice(2,1,"duck" , "animal")
        arr;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<div class="codeblock"> 
    <code class="1c">
        var arr = [] ;
        arr.push("1");
        arr.push({"a": "test"});
        arr.push(3);
        arr.splice(2,1) //from 2 to next 4 elements
        arr;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<div class="codeblock"> 
    <code class="1c">
      var str = "boston";
      str.slice(2,5);
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<div class="codeblock"> 
    <code class="1c">
        var arr = [] ;
        arr.push(1);
        arr.push(13);
        arr.push(5);
        arr.push(7);
        
        arr.sort((a,b) =>  a-b);
        arr;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>
<p> usage of new operator. Consider a function Plan() , and when we assign anything via prototype 
    
, all Plan objects have same data </p>
<div class="codeblock"> 
    <code class="1c">
    function Plan()
    {
      var t = {  Name : "John",
        calc : function()
        {
            
        }
    }
    }
    var plan1 = new Plan();
    var plan2 = new Plan();
    //All plans have this new copy
   
    Plan.prototype.test = "Jack";
    //all plans have this shared
    plan1.test;

     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>
<p>To know if a property is from inheritance or by self</p>
<div class="codeblock"> 
    <code class="1c">
        function Plan()
    {
      var t = {  Name : "John",
        calc : function()
        {
            
        }
    }
    }
    var plan1 = new Plan();
    var plan2 = new Plan();
    //All plans have this new copy
   
    Plan.prototype.test = "Jack";
    //all plans have this shared
    plan1.hasOwnProperty("test");
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<hr/>
<h2>Browser APIs</h2>
<ul>
    <li>window.location.href<sub>location url</sub></li>
    <li>window.location.hostname<sub>domain name </sub></li>
    <li>window.location.pathname<sub>query params after .com</sub></li>
    <li>window.location.hash<sub>id referencing any id element , www.abc.com#123</sub></li>
    <li>window.location.assign<sub>keep history intact</sub></li>
    <li>window.location.replace<sub>does not record in history</sub></li>
    <li>window.location.reload(true)<sub>reloads from server </sub></li>
    <li>window.location.reload()<sub>reloads from cache</sub></li>
    <li>window.history.back()</li>
    <li>window.history.forward()</li>
    <li>window.history.go(2)</li>
</ul>
<hr/>
<h2>Jquery API</h2>
<ul>
    <li></li>
</ul>
<hr/>
<h4>Type conversion</h4>
<ul>
    <li><code>string(value)<sup>converts to string</sup></code></li>
    <li><code>Number("123")<sup>converts to Number</sup></code></li>
    <li><code>Number(null)<sup>0</sup></code></li>
    <li><code>Number(undefined)<sup>NaN</sup></code></li>
    <li><code>Number(123z)<sup>NaN</sup></code></li>
    <li><code>Number(" 123 ")<sup>123</sup></code></li> 
</ul>

<p>** exponential operator , highest precedence</p>
<br/>
<p>delete object property using delete </p>
<div class="codeblock"> 
    <code class="1c">
       var user = {
        name : "Andy",
        age : 24,
        dob : "help"
       }
       delete user.age;
       user.age === undefined;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Object property key can hhave only symbol and string properties</p>
<hr/>
<h2>Symbol</h2>
<p>Symbols are uniquely generated</p>
<div class="codeblock"> 
    <code class="1c">
      let id1 = Symbol();
      let id2 = Symbol();
      id1 == id2
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<p>Symbols dont auto-convert</p>
<div class="codeblock"> 
    <code class="1c">
        let id1 = Symbol();
        let id2 = Symbol();
        //alert(id1); // error
        id1.toString()
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Since symbols are unique , we can assign properties using them and 
    no overwriting happens </p>
<div class="codeblock"> 
    <code class="1c">
      let id1 = Symbol();
      let id2 = Symbol();
      let user = {
          name : "Abc",
          age : 40 
      }
      user[id1] = "John";
      user[id2] = "Jason"
      user[id1] + " " + user[id2]
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>For-in symbols are skipped.Only Object.assign <sub>object method</sub> copies all properties</p>
<div class="codeblock"> 
    <code class="1c">
      let id = Symbol();
      let user = {
          Name : "Andy",
          age : 24,
        [id] : "Symbol prop"
      }
      let allproperties = "";
      for (var key in user)
      {
         allproperties += key + " ";
      }
      allproperties;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Object.assign copies both string and symbol properties</p>
<div class="codeblock"> 
    <code class="1c">
        let id = Symbol();
        let copieduser = {};
        let user = {
            Name : "Andy",
            age : 24,
          [id] : "Symbol prop"
        }
        Object.assign(copieduser,user);
        copieduser[id];
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>
<p>Object.assign copies all elements from source to target and returns target Object.assign(target,source)</p>

<p>Use Symbol.for(key) to get same symbol value and Symbol.KeyFor()</p>
<p>symbol.for(string) and symbol.forKey(symbol) </p>
<div class="codeblock"> 
    <code class="1c">
       let id = Symbol("abc");
       let sym = Symbol.for("abc");
       let id1 =  Symbol.keyFor(sym);
       id1 === "abc"
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<div class="codeblock"> 
    <code class="1c">
       let id = Symbol("abc");
       let sym = Symbol.for("abc");
       let id1 =  Symbol.keyFor(sym);
       id1 === "abc"
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<br/>
<h3>Object to primitive conversion</h3>
<p>object to boolean always works as true</p>
<p>object to string and number follows these rules</p>

<p>There are three possibilities for conversions</p>
<ol>
    <li>object to string</li>
    <li>object to Number</li>
    <li>object to Default , when its not sure what to expect and hint in that case is 'default'</li>
</ol>
<p>The algo for conversion:-</p>
<p>
<ol>
    <li>Call obj[Symbol.toPrimitive](hint) â€“ the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,</li>
<li>Otherwise if hint is "string"</li>
    <ul>
        <li>try obj.toString() and obj.valueOf(), whatever exists.</li>
    </ul>
<li> Otherwise if hint is "number" or "default"</li>
   <ul><li>try obj.valueOf() and obj.toString(), whatever exists.</li></li></ul>
</ol>
</p>
<p>Number hint</p>
<div class="codeblock"> 
    <code class="1c">
        let user = {
            name : "John" , 
            money : 1000 ,
            [Symbol.toPrimitive](hint)
            {
                if(hint == "string")
                {
                    return this.name;
                }
                if (hint == "default") 
                {
                    return "default"
                }
                if(hint == "number")
                {
                    return this.money
                }
                //must return
                
            },
  
            toString()
            {
                console.log("to string");
              //return type is ignored
            },
  
            valueOf()
            {
                console.log("value of")
              //return type is ignored
            }
        }
        ++user;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>
<p>string hint</p>
 <div class="codeblock"> 
        <code class="1c">
            let user = {
                name : "John" , 
                money : 1000 ,
                [Symbol.toPrimitive](hint)
                {
                    if(hint == "string")
                    {
                        return this.name;
                    }
                    if (hint == "default") 
                    {
                        return "default"
                    }
                    if(hint == "number")
                    {
                        return this.money
                    }
                    //must return
                    
                },
      
                toString()
                {
                    console.log("to string");
                  //return type is ignored
                },
      
                valueOf()
                {
                    console.log("value of")
                  //return type is ignored
                }
            }
            user;
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>
<br/>

<br/>
<p>default hint</p>
 <div class="codeblock"> 
        <code class="1c">
            let user = {
                name : "John" , 
                money : 1000 ,
                [Symbol.toPrimitive](hint)
                {
                    if(hint == "string")
                    {
                        return this.name;
                    }
                    if (hint == "default") 
                    {
                        return "default"
                    }
                    if(hint == "number")
                    {
                        return this.money
                    }
                    //must return
                    
                },
      
                toString()
                {
                    console.log("to string");
                  //return type is ignored
                },
      
                valueOf()
                {
                    console.log("value of")
                  //return type is ignored
                }
            }
            user + "";
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>

<p>if symbol[primitive] is not present then JS tries to use toString or valueOf</p>
<p>By default, a plain object has following toString and valueOf methods:</p>
 <div class="codeblock"> 
        <code class="1c">
            let user = {
                name : "John" , 
                money : 1000 ,
               toString()
                {
                   return this.name;
                  //if object is returned , it is ignored
                },
      
                valueOf()
                {
                    return this.money;
                    //if object is returned , it is ignored
                }
            }
            user*2;
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>

<br/>
<div class="codeblock"> 
    <code class="1c">
        let user = {
            name : "John" , 
            money : 1000 ,
           toString()
            {
               return this.name;
              //if object is returned , it is ignored
            },
  
            valueOf()
            {
                return this.money;
                //if object is returned , it is ignored
            }
        }
        user;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>

<p>
    <ul>
        <li>toString() and valueOf() can return anything exception objects(non-primitive)</li>
        <li>By default toString() has [object Object] representtaion</li>
        <li>first toString is tried and then valueOf is tried. if toString() is not found in the object , its prototype is also searched</li>
        <li></li>
    </ul>
</p>
<hr/>
<p>inside a function we can determine using <code>new.target</code> if the function was called using new or directly </p>
<p>If return is called with an object then the object is returned instead of this</p>
<p>if return is called with primitive , it is ignored and "this" is returned</p>

<h1>Data types</h1>
<h2>methods of primitive</h2>

<p>to convert a number to binary , use  </p>
<div class="codeblock"> 
    <code class="1c">
        var num = 34;
        num.toString(2);
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>

<p>Math class in JS</p>
<ul>
    <li>Math.floor</li>
    <li>Math.ceil</li>
    <li>Math.round</li>
    <li>Math.trunc</li>
    <li>num.toFixed()</li>
    <li>Math.random()</li>
    <li>Math.max(a,b,c)</li>
    <li>Math.pow(n,power)</li>
</ul>


<p>isNaN(NaN)</p>
<div class="codeblock"> 
    <code class="1c">
        (isNaN(NaN) == isNaN("-5")) 
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>

<br/>

<div class="codeblock"> 
    <code class="1c">
        (NaN == NaN)//false , hence use isFinite 
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>


<p>isFinite("15")</p>
<div class="codeblock"> 
    <code class="1c">
        !(isFinite(Infinity) == isFinite(-Infinity)) == isFinite(NaN)
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>


<p>Object.is</p>
<div class="codeblock"> 
    <code class="1c">
        Object.is(NaN, NaN) == Object.is(0,-0)  //true === false;        
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>
<p> for rest all cases its === match</p>


<br/>
<p>ParseInt</p>
<p>ParseFloat</p>
<hr/>


<h3>Strings</h3>
<p><code>str[3] = 'a'</code> // will give error</p>

<h1>Array</h1>
<p><code>let arr = new Array();</code></p>
<p><code>let arr = []</code></p>
<p>Arrays are objects , copied by reference,</p>
<p>Arr.Length is both read and writeable</p>
<h4>Arra methods</h4>
<ul>
    <li>delete arr[1]</li>
    <li>arr.splice(sratindex , delete count , [elements to be inserted])</li>
    <li>arr.concat(arr1,arr2 ...)</li>
   
    <div class="codeblock"> 
        <code class="1c">
            var arr = [];
            arr.concat([3,4] , [5,6]);      
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
    </div>
    <p>if we concat an object , object is concated not its properties</p>
    
    <div class="codeblock"> 
        <code class="1c">
            var arr = [];
            let arralike = {a :"john" , age : 52}
            arr.concat([3,4] , [5,6] , arralike);      
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
    </div>

    <p>to concat properties , set [symbol.IsConcatSpreadable] to true<sub>make sure length property is also in object</sub></p>
    
    <div class="codeblock"> 
        <code class="1c">
            var arr = [];
            let arralike = {1 :"john" ,
                            age : 52 ,
                            [Symbol.isConcatSpreadable]: true ,
                             length : 2 }
            arr.concat([3,4] , [5,6] , arralike);      
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
    </div>

    <li>arr.indexOf(item,from index)<sub>-1 if no match</sub></li>
    <li>arr.lastIndex(item , from index)<sub>-1 if no match</sub></li>
    <li>arr.includes(item , from)<sub>uses === and not ==</sub></li>
    <li>arr.find(fn(item , index, arr))<sub>is called again and again for arr elements , once true is returned search is stopped. Returns just a single element</sub></li>
    <li>arr.filter(fn(item , index, arr))<sub>multiple elements are returned</sub></li>
    <li>arr.map(fn(item , index, arr))<sub>calls method for each element and result arra is returned</sub></li>
    <li>arr.sort(function)</li>
    <li>arr.reverse()</li>
    <li>arr.join(',')<sub>returns string</sub></li>
    <li>str.split(',')<sub>returns array</sub></li>
    <li>arr.reduce(function(item,index,array,prevValue))</li>
    <li>const removeDups = arr => [...new Set(arr)] will remove the duplicates from array</li>
    
    <div class="codeblock"> 
        <code class="1c">
            arr = [1,2,3,4,5]
            arr.reduce((sum , current) => sum + current)      
         </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
    </div>
    <li>forEach, runs foreach elements </li>
    <li>Array.IsArray[] to check if something is array</li>
    <li>Almost every array function has "this" arg except sort</li>
</ul>
<hr/>
<h1>Iterable</h1>
<p>Are abstraction of arrays</p>
<p>Allow ud to use for-of loop</p>
<p><b>to make an iterator , add a method called symbol.iterator</b></p>
<ul>

    <li>
        when for-of is called , it calls Symbol.Iterator method
    </li>
    <li>method must return an iterator (an object with next method)</li>
    <code>next() --> {done : true ,value : "abc"}</code>
    <li>iterables are objects which implement symbol.iterator and Arrays are objects with Indexes</li>
    <li><b>Array from iterator</b> Array.from(arraylike)</li>
    <li><b>Array from iterator</b> <code>Array.from(arraylike , fn )</code></li>

</ul>

<div class="codeblock"> 
    <code class="1c">
        
            let arr = [1,2,3,4,5,6,7,8,9];
            var i = -1;
            var user = {
             }
            user[Symbol.iterator] = function() {
                return {
                        next()
                            {
                                i++;
                                console.log("abc");
                                return {done : i > arr.length -1 ,value : arr[i] }
                            }
                        }

            }
            
            var data =""
            for (let u of user)
            {
                data = data + " " + u;
            }  
            data;   
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>

<p>get next value without calling for-of</p>

<div class="codeblock"> 
    <code class="1c">
        
            let arr = [1,2,3,4,5,6,7,8,9];
            var i = -1;
            var user = {
             }
            user[Symbol.iterator] = function() {
                return {
                        next()
                            {
                                i++;
                                console.log("abc");
                                return {done : i > arr.length -1 ,value : arr[i] }
                            }
                        }

            }
            
            var data = user[Symbol.iterator]();
            data.next().value;
            
          
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />

</div>
<h2> Map , set , weakmap , weakSet </h2>
<h4>Map</h4>
<p>Map is a collection of keyed data , just like an object</p>
<p>Methods:-</p>

<ul>
    <li>new Map()</li>
    <li>map.set(key,value)</li>
    <li>map.get(key)</li>
    <li>map.has(key)</li>
    <li>map.delete(key)</li>
    <li>map.clear()</li>
    <li>map.size()</li>
    <li>map.set()</li>
    <li>create map from object<sub>Object.entries also returns key/value pairs in that format</sub></li>
    <code>let map = new Map([
        ['1' , 'Str1'],
        [1, 'num1'],
        [true , 'bool1']
        ])
    </code>
    <li>Map.Keys() , map.Values() , map.entries()</li>
    <li>foreach also available in Map()</li>
</ul>

<h4>Set</h4>
<p>is a collection of values</p>
<ul>
    <li>new Set(iterable)</li>
    <li>set.add(value)</li>
    <li>set.delete(value)</li>
    <li>set.has(value)</li>
    <li>set.clear()</li>
    <li>set.size</li>
    <li>Adding duplicate to set will not add a new element but just give an error(does not give error ) </li>
    <li>iteration is possible using foreach /for-of</li>
</ul>


<h4>Weak-map</h4>
<p>It is removed from memory once object is null</p>
<ul>
    <li>only object is allowed as Key</li>
    <li><code>let w = new WeakMap();
        let obj = {};
        w.set(obj,"OK");
        obj = null ,
        w.get(obj); //undefined 
    </code></li>
    <li>weak map does not have keys() , values() entries().cant be iterated over as well </li>
    <li></li>
</ul>



<h4>Object methods , Keys() , values() , entries()</h4>
<p>these methods are also supported by Map , set , Array</p>
<ul>
    <li>Object.Keys(obj)</li>
    <li>Object.Values(obj)</li>
    <li>Object.Entries(obj) , returns k,v pairs </li>
    <li>All these prperties return non-symbolic properties</li>
    <li>to get symbolic properties , use Object.getOwnPropertySymbols</li>
    <li>Object.entries(obj) and Object.Fromentries(arrofobj) are compementary</li>
</ul>
<p>Object.keys</p>
<div class="codeblock"> 
    <code class="1c">
    var obj = {
    name : "Anurag" ,
    age : 5
    }         
    Object.keys(obj);
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Object.values</p>
<div class="codeblock"> 
    <code class="1c">
    var obj = {
    name : "Anurag" ,
    age : 5
    }         
    Object.values(obj);
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Object.entries</p>
<div class="codeblock"> 
    <code class="1c">
    var obj = {
    name : "Anurag" ,
    age : 5
    }         
    Object.entries(obj);
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<p>include symbols</p>
<div class="codeblock"> 
    <code class="1c">
    var sym =  Symbol("symbol");
    var obj = {
            [sym] : 45,    
            name : "Anurag" ,
            age : 5
        }         
    Object.getOwnPropertySymbols(obj)[0].toString()
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<h1>Destructuring</h1>
<p>A special syntax to allow us to "unpack" arrays or object into a bunch of variables</p>

<p>destructuring</p>
<div class="codeblock"> 
    <code class="1c">
    let arr = [1,2,3];
    let [A,B,C] = arr;
    A;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<p>Array destructuring</p>
<div class="codeblock"> 
    <code class="1c">
    let arr = [1,2,3,4,5,6,7,8];
    let [A,B,C , ...rest] = arr;
    rest[1];
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<p>Object destructuring</p>
<div class="codeblock"> 
    <code class="1c">
        let obj = {k:"Andy" , l : "test"};
        let {k,l} = obj;
        k;
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>Json.Parse and .stringify() calls .toJson if available else uses in-built one</p>
<div class="codeblock"> 
    <code class="1c">
        json.parse();
        json.stringify();
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>

<p>REST params and spread. Object.assign() appends and copies data from src to destination</p>
<div class="codeblock"> 
    <code class="1c">
        let obj1 = {
            a: "abc",
            age : 54
        }

        let obj2 = {
            a1: "test",
            age1 : 45
        }

        let dest = {}
        Object.assign(dest,obj1,obj2);
        dest.a1;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>


<p>There is also an arguement variable where we can access arrays</p>

<p>When in a function call , ...arr is expanded to an iterable</p>
<h4>Named function expressions vs function expression vs Anonymous functions</h4>
<p>to refer current function inside body , use NFE</p>
<p>NFE's are not hoisted</p>
<p>function expression vs function declaration.fnction expression is used for IIFE</p>
<p>there is no internal name for function declaration</p>
<p>NFE's function name are not visible outside functin</p>

<div class="codeblock"> 
    <code class="1c">
        var t = "";
        var k = "";
      var func = function abc(a)
      {
            if(a === 1)
            {
                abc(2);
                k = a;
            }
            t = a;
      }

      func(1);
      k;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<br/>
<h1>decorators and call forwarding</h1>
<p>Caching :- any CPU intensive program can be cached for response</p>
<p>a decorator is a function that takes another function and alters its behaviour </p>
<p>Three decorators :-</p>
<ul>
    <li>Call</li>
    <li>apply</li>
    <li>bind</li>
</ul>

<p>Syntax of call :- fn.call(context , arg1 , arg2 ..)</p>

<div class="codeblock"> 
    <code class="1c">
        var t = "";
        function say(phase)
        {
            t = this.name + " " + phase;
        }
        let user = { name : "John"};
        say.call(user , "Hello");
        t;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>

<p>Syntax of apply :- fn.apply(context , args)</p>
<p>apply accepts only iterable , call can accept iterable using ...</p>


<div class="codeblock"> 
    <code class="1c">
        var t = "";
        function say(phase)
        {
            t = this.name + " " + phase;
        }
        let user = { name : "John"};
        say.call(user , "Hello");
        t;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>

<p>Bind</p>
<p>returns a bound function that has same context as with call</p>
<div class="codeblock"> 
    <code class="1c">
        var t = "";
        function say(phase)
        {
            t = this.name + " " + phase;
        }
        let user = { name : "John"};
        var bound = say.bind(user);
        bound("John");
        t
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    <p>There is also another overload of bind . check</p>

</div>

<h4>Currying and partial function</h4>
<p>currying is converting a function of type method(a,b,c) to method(a)(b)(c)</p>
<div class="codeblock"> 
    <code class="1c">
        // Normal function
        function addition(x, y) {
             return x + y;
            }
        // Curried function
    function addition(x) {
            return function(y) {
        return x + y;
    }
}   

     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    <p>There is also another overload of bind . check</p>

</div>

<h4>arrow functions</h4>
<ul>
    <li>Arrow functions have no this</li>
    <li>cant access "arguements" variable</li>
    <li>Arrow functions does not have new construtor calls</li>
</ul>

<h3>Property flags + descriptors</h3>
<p>Object prop has 4 attributes</p>
<ul>
    <li>value<sub>actual value</sub></li>
    <li>writeable<sub>if true it can be changes else read-only</sub></li>
    <li>enumerable<sub>actuif true available in loopsal value</sub></li>
    <li>configurable<sub>if true property can be deleted and attribute can be modified</sub></li>    
</ul>

<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"}
       let descriptor = Object.getOwnPropertyDescriptor(obj , "A")
       descriptor.__proto__.toString = function()
       {
         return "value :-" + this.value + "\n" + "writeable:-" + this.writable + "\n"+
          "enumerable:- " + this.enumerable + "\n" + "configurable:- "+ this.configurable;
           
       }
       descriptor;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    
</div>
<p>There is also another overload of bind . check</p>


<p>Object.defineProperty</p>
<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"}
       let descriptor = Object.defineProperty(obj , "A" ,
       {
           value : "John"
       });
       
       descriptor.A;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>
<p>writeable</p>
<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"}
       let descriptor = Object.defineProperty(obj , "B" ,
       {
          value : "init", writeable : false 
       });
       
       descriptor.B = "test1";
       descriptor.B
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>
<p>non-enumerable</p>
<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"}
       let descriptor = Object.defineProperty(obj , "B" ,
       {
           value : "jason" , enumerable : false
       });
       var l = ""
       for(var t of obj)
       {
          //error obj is not iterable 
       }
       
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>


<p>non-configurable</p>
<p>Only one way road , once set to true "defineproperty" cant change it</p>
<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"}
       let descriptor = Object.defineProperty(obj , "B" ,
       {
           value : "jason" , configurable : false
       });
       //trying to configure descriptor
       Object.defineProperty(descriptor , "B" ,
       {
           value : "john" , configurable : false
       });
       
       //cannot redefine property
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>



<p>we can use defineProperty to clone objects</p>
<div class="codeblock"> 
    <code class="1c">
       let obj = {A:"test"};
       let prop = Object.getOwnPropertyDescriptors(obj);
       let clone = Object.defineProperty(obj , prop.A
       );
      
       obj == clone
      

     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<p>To seal an object globally , use  <code>Object.preventExtension(obj)</code></p>


<h2>Getter and setter</h2>
<p>There are two tyepes of proeprties</p>
<ul>
    <li>Data properties</li>
    <li>accesor properties</li>
</ul>

<p>Accesors  have 4 properties</p>
<ul>
    <li>get<sup>a fun that is called when a prop is get</sup></li>
    <li>set<sup>a fn that is called when a prop is set</sup></li>
    <li>enumerable</li>
    <li>configurable</li>
</ul>


<div class="codeblock"> 
    <code class="1c">
        var name = "";
      let user =  {
          
          get fullname(){
            return "different Andy";
          },
          set fullname(value)
          {
            name = value;
          }
      }
       user.fullname = "Andy";
       user.fullname;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>


<p>We can define get/set internally like so:-</p>
<div class="codeblock"> 
    <code class="1c">
        let user = {};
       Object.defineProperty( user, "abc" , {
           set() {

           }
       });
    user.abc;
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<h2>Prototypes</h2>
<ul>
    <li>In JS all objects have [[prtotype]] property</li>
    <li>its either null or points to an object but never both or primitive type</li>
    <li>__proto__ is a getter setter for prototype</li>
    <li>this keyword is not affected by prototype , it always points to prev object</li>
    <li>If a metod or prop is not present in object , it is found in prototype</li>
    <li></li>
</ul>

<p>Every function has a default prototype property.</p>
<p>Default prototype is an object with only property "contructor" that points back to itself</p>
<p>When we use new F() , objects [[prototype]] is set to F.prototype</p>

<sup>Default prototype is an object with only property "contructor" that points back to itself</sup>
<div class="codeblock"> 
    <code class="1c">
        function Rabbit()
        {

        }
        Rabbit.prototype.constructor
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<p>When we use new F() , objects [[prototype]] is set to F.prototype</p>
<div class="codeblock"> 
    <code class="1c">
        function Rabbit()
        {

        }
        let rabbit = new Rabbit();
        rabbit.constructor == Rabbit
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<p>ctor 's prototype points to object prototype</p>
<div class="codeblock"> 
    <code class="1c">
        let obj = {};
       obj.__proto__ == Object.prototype
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<ul>
    <li>For primitives such as Number , string , boolean a wrapper is created at runtime</li>
    <li>Null and undefined have no wrapper</li>
</ul>

<p>We can extend something with prototype like so:-</p>
<div class="codeblock"> 
    <code class="1c">
        String.prototype.show = function(){
            alert(this);
        }
        "abc".show();
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<p>Generally polyfill libs use this t port a feature in ES5 from ES6</p>
<h4>Ways to get/set prototype</h4>
<ul>
    <li>Object.create(proto [ ,descriptors)</li>
    <li>Object.setPrototypeOf(obj)</li>
    <li>Object.getPrototypeOf(obj)<sub>returns prototype of obj</sub></li>
    <li>Object.create(null)</li>
</ul>

<p>Get key values from JS</p>
<ul>
    <li>Object.keys(obj)</li>
    <li>Object.Values(obj)</li>
    <li>Object.Entries(obj)</li>
    <li>Object.getOwnProperty(obj)<sub>gets only symbolic properties</sub></li>
    <li>Object.ownKeys(obj)<sub>non enumerable props</sub></li>
    <li>Reflect.OwnKeys(obj)<sub>when we want all props</sub></li>
    <li>Obj.hsOwnProperty(key)<sub>For differentiating built-in vs inherited</sub></li>
</ul>

<h3>3 ways to implement inheritance</h3>
<ul>
    <li>factory based<sub>without new keyword</sub></li>
    <li>prototype based<sup>Rabbit.prototype.__proto__ = animal.prototype</sup></li>
    <li>fn based<sub>with new keyword</sub></li>
</ul>
<h2>Class</h2>
<p>Classes in ES6</p>
<div class="codeblock"> 
    <code class="1c">
      class User {
          constructor(name)
          {
              alert(name)
          }

          sayhi(name)
          {
              alert(name);
          }
      }

      let user = new User("hello");
      user.sayhi("John");

     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>


<ul>
    <li>ctor can be called w/o new keyword</li>
    <li>classes have default ctor</li>
    <li>classes are non-enumerable</li>
    <li>classes always use strict</li>
    <li>classes ay have get /set</li>
    <li>In a class only get/set and methods are allowed, no prop:value</li>
    <li>can have static method , this inside it will be class name and can be called by class name</li>
</ul>

<p>.super.method() calls parent class method</p>
<p>.super() calls parent class ctor</p>
<p>super is not accesible in arrow function</p>
<p>When we have A: B then A() must call super()</p>
<p>When we have A: B then A() must call super() before calling this, this is because JS automatically does not call parent class ctor</p>
<code>
    ctor(...args)
    {
        ctor(...args)
        {
            super(...args);
        }
    }
</code>
<p>To point immediate parent [[HomeObject]]</p>
<p>static inheritance also supported un User defined objects</p>

<div class="codeblock"> 
    <code class="1c">
    class Animal{
        static abc(name)
        {
            alert(name);
        }
    }

    class Rabbit extends Animal{

    }
    Rabbit.abc("hello");
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>
<p>static inheritance doesn't work with inbuilt objects</p>


<p>instanceof</p>
<p>The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.
</p>
<code>object instanceof constructor</code>
<div class="codeblock"> 
    <code class="1c">
    class Rabbit{

    }
    var rabbit = new Rabbit();
    rabbit instanceof Rabbit
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<p>symbol.hasInstance</p>
<p>Custom implementation of instanceof</p>
<p>If there is no implementation of symbol.hasInstance them it is searched in prototype chain</p>
<div class="codeblock"> 
    <code class="1c">
        class MyArray {  
            static [Symbol.hasInstance](instance) {
              return false
            }
          }
          [] instanceof MyArray // false
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
   
</div>

<h2>Mixins</h2>
<p>Mixins is a class that contains method for use by other classes w/o having to be the parent class</p>
<div class="codeblock"> 
    <code class="1c">
        const knowsBackend = 
        {
            testBackEnd()
            {
                return true;
            }
        }

        const knowsFrontEnd = 
        {
            testFrontEnd()
            {
                return true;
            }
        }

        const user = Object.assign({} , knowsBackend ,knowsFrontEnd);
        user.testBackEnd();
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>

<h2>Error Handling</h2>
<div class="codeblock"> 
    <code class="1c">
       try
       {
           let user = {};
           user.test;
           user.test();
       }
       catch(err)
       {
           err.name + "###" + err.message + "###" + err.stack;
       }
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<p>To create your own errors</p>
<ul>
    <li>Error()</li>
    <li>SyntaxError()</li>
    <li>ReferenceError()</li>
    <li>TypeError()</li>
</ul>
<p>to throw erro use <code>throw ex</code></p>

<p>Can exten a error class</p>
<code>
    class AbcError extends error{

    }
</code>
<p>We have window.onerror callback that can be used to log errors</p>
<h2>promises</h2>
<p>Promise is a js object that that links producing and consuming code</p>
<div class="codeblock"> 
    <code class="1c">
        //producer code
      let promise = new Promise((resolve ,reject) =>
      {
          //async code
        navigator.geolocation.getCurrentPosition((position) =>
        {
            //on successfully working, call then at consumer with passed params
            resolve(position.coords.latitude + " "+ position.coords.longitude)
        } 
        //on failure , call catch at consumer code with these params
        , ()=> reject("user is paranoid"));
      
      });

      //consumer code
      promise
      .then((value) => alert(value))
      .catch((value) => alert(value))
      .finally(()=>alert("done with geolocation DEMO"));
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<p>promise has two properties:-</p>
<ul>
    <li>state</li>
    <li>result</li>
</ul>
<p>promise can either resolve or reject and only once</p>
<p>a promise can return another promise , but it need not . It can return an object with then() functions</p>
<p>fetch returns a promise</p>
<p>any error in then is caught by catch outside</p>
<p>any uncaught error is sent to windows eventhandler , "unhandled rejections"</p>


<table>
    <tr>
        <td style="background-color: brown;">state</td>
        <td style="background-color: brown;">result</td>
        
    </tr>
    <tr>
        <td>pending</td>
        <td>undefined</td>
    </tr>
    <tr>
        <td>rejected</td>
        <td>error</td>
        
    </tr>
    <tr>
        <td>
            fulfilled
        </td>
        <td>
            done
        </td>
    </tr>
</table>
<h4>Promise.API</h4>
<ul>
    <li>Promise.All(array of promises)</li>
    <li>Promise.All(Iterable of promises)</li>
    <li>Promise.allSettled</li>
    <li>Promise.race([])</li>
    <li>Promisification</li>
</ul>

<p>Promise.All(array of promises)</p>
<div class="codeblock"> 
    <code class="1c">
        let promise1 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("1")} , 1000);
        });

        let promise2 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("2")} , 2000);
        })

        let promise3 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("3")} , 5000);
        })

        let finalPromise =  Promise.all([promise1,promise2,promise3]);
        finalPromise.then(()=> alert("success")).catch(() => alert("failure"))
     </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>


<p>Promise.allSettled(Iterable  or array of promises)</p>
<div class="codeblock"> 
    <code class="1c">
        let promise1 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("1")} , 1000);
        });

        let promise2 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("20")} , 2000);
        })

        let promise3 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("30")} , 5000);
        })

        let finalPromise =  Promise.allSettled([promise1,promise2,promise3]);
        finalPromise.then((arg)=> arg.forEach((x) => alert(x.status + " " + x.value))).catch(() => alert("failure"))
        
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>


<p>Promise.Race(Iterable  or array of promises)</p>
<div class="codeblock"> 
    <code class="1c">
        let promise1 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("1")} , 1000);
        });

        let promise2 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("20")} , 2000);
        })

        let promise3 = new Promise((resolve,reject)=>
        {
            setInterval(()=>{resolve("30")} , 5000);
        })

        let finalPromise =  Promise.race([promise1,promise2,promise3]);
        finalPromise.then((x)=>  alert(x)).catch(() => alert("failure"))
        
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>



<p>Promisification(turns a function that accepts a callback to promise)</p>
<div class="codeblock"> 
    <code class="1c">
        
        function withcallback(x , cb)
        {
            cb(x);
        }

        withcallback("2" , console.log)
        let finalPromise =  promisify(withcallback);
        finalPromise.then((x)=>  alert(x)).catch(() => alert("failure"))
        //custom implementation needed
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>


<h4>Async/await</h4>
<p>async keyword can be put before any function</p>
<code>
    async function f(){
        return 1;
    }
</code>
<p>this means it will return a promise f().then(alert) can be used</p>
<p>we could also return a promise , it will also be same as above</p>
<code>
    async function f()
    {
        return promise.resolve(1);
    }
    f().then(alert);
</code>
<p>JS awaits till promise id resolved and then returns a result</p>
<div class="codeblock"> 
    <code class="1c">
        async function f()
        {
        let promise = new Promise((resolve , reject) => 
        {
            setTimeout(() => resolve("done") , 1000)
        })

        let result = await promise;
        alert(result);
    }
    f();
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<ul>
    <li>we cant use async in regular functions , only in async functions</li>
    <li>cant be used at top level , ex <code>let res = await fetch(""") , use IIFE instead</code></li>
    <li>await can accept thenables , not necessarily promises</li>
    <li>error in case of async</li>
</ul>
    <code>
        async function f()
        {
            await promise.reject(new Error(""))
        }

        is same as 
        async function f()
        {
            throw new Error("whoops");
        }
    </code>

<h3>Generatos</h3>
<ul>
    <li><b>function*</b> can return multiple values</li>
    <div class="codeblock"> 
        <code class="1c">
            function* generatorfunc(index) {
                while (index < 2) {
                  yield index++;
                }
              }
            const iterator =  generatorfunc(-2)
            iterator.next().value
            iterator.next().value
            iterator.next().value
        </code>
        <br/>
        <code class="1a"></code>
        <br/>
        <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
    </div>
    <li>each generator object has a next method</li>
    <li>each next returns an object {value : , done : }</li>
    <li>function* f() or function *f() both are correct</li>
    <li>generator fns are iterables , can be accesed in for-of loop. loop will igore vlues when done is true</li>
    </ul>

    <h4>Async iterator generator</h4>
    <p>Three differences between normal iterator and async iterator</p>
    <ul>
        <li>instead of Symbol.Iterator use Symbol.asyncIterator</li>
        <li>next() should return a promise</li>
        <li>to loop use await for(var t of iter)</li>
        <li>spread does not works with asyc iterables</li>
    </ul>
<h3>Modules</h3>
<p>using export we can export functions</p>
<div class="codeblock"> 
    <code class="1c">
        export function sayhi()
        {

        }

        import {sayhi} from '../sayhi.js'
        sayhi('john');
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>

<p>for browsers we need to use </p>
<code>
    <script type="module">
    import {sayhi} from '../sayhi.js'
    </script>
</code>

<p>difference between module vs normal files</p>
<ul>
    <li>modules always use strict</li>
    <li>all modules have top-level scope , and cant share vars</li>
    <li> module code is evaluated only once when imported</li>
    <li>Also changes ade to exported code is visible to all  modules</li>
    <li>this is undefined in module</li>
</ul>
<p>script type="module" is deferred , in contrast to script</p>
<p>script type="module" src="" , doesnt block HTML processing , they load in parallel</p>
<p>running of module script happens, only after HTML is ready</p>
<p>first script in page is executed first</p>
<p>If we want modules to run immediaately , use async keyword</p>
<code>
    <script async type="module">
        //doesnt wait for HTML load
    </script>
</code>
<p>bare modules are not allowed in browser. import w/o script src  , import {sayhi} from 'sayhi'  // error </p>
<p>nomodule -> old browser do not understand modules need this</p>
<h4>How build tools work</h4>
<p>take main module file to be put in <code> script type = "module"</code></p>
<p>gets its dependencies , and imports it and then imports of imports</p>
<p>gets it all in a single file</p>
<p>processes other optimizations</p>
<h4>export before declarations</h4>
<p>We can export any declarations , fn , class , variable</p>

<code>
    export let months = ['month' , 'feb']
    export const MOD_BEC = 2015;
    export class user{
        ctor(name)
        {
            this.name _name ;
        }
    }
    //no semicolon needed
</code>
<p>
export separately:- 
function sayHi(user)
{

}
export {sayHi}
</p>

<p>
    <code>
        import x from ''
        vs
        import {sayHi} from ''
        
    </code>
    webpack will still keep all the unused module import
</p>

<p>use as as import statement</p>
<code>
    import {sayhi as hi} from ''
    export {sayhi as asdf} // official name to be used by all modules
</code>
<p>default exports</p>
<code>

    export default class user{

    }

</code>
we try to keep a single export per file 

<p>import user1 from ''</p>
<ul>
    <li>while importing default we can use :- our our name to import</li>
    <li>No curly braces</li>
    <li>we can have both default & normal export in same module</li>
    <li>we could also use export{sayhi as default}</li>
    <li>import both default and named in same line .import {default as user , sayhi} from ''</li>
    <li>default exporting is discouraged as each dev can use own</li>
    <li>re-export also possibe , export {sayhi} from ''</li>
    <li>re-export  deafult dont use , export user from '' but use  export {default as sayhi} from ''</li>
    <li>export * from '' --> exports only named xports and ignores default</li>
    <li>export {default} from '' --> will re-export defaut </li>
    </ul>

<h4>Dynamic Import</h4>
<p>all previous imports were static</p>
<p>import from dynamic path. , Import() loads a module & returns a promise</p>
<code>
    let modulePath = prompt(" ");
    import(modulePath).then().catch();

    or 

    let {hi , bye} = await import();
    hi();
    bye();
</code>
<p>In case of defalt dynamic import</p>
<code>
    let ob = await import();
    let sy = ob.default;
    say();
</code>

<h4>Proxy and reflect</h4>
<p>A proxy object wraps another object and intercepts operation like reading and writing</p>
<code>
let proxy = new Proxy(target , handler);
handler has 
a) config :- an object 
b) traps -> get (for reading a prop)
set (for writing to prop)

</code>
<div class="codeblock"> 
    <code class="1c">
        let target = {} ;
        let proxy = new Proxy(target , {});
       // since no handler traps all operation are forwarded to target
    proxy.test = 5;
    proxy.test
    </code>
    <br/>
    <code class="1a"></code>
    <br/>
    <input id="1b" class="btn btn-primary" onclick="calc(event)" type="button" value="evaluate" />
</div>
<p>list of traps</p>
<ul>
    <li>get</li>
    <li>set</li>
    <li>has</li>
    <li>deleteproperty</li>
    <li>apply</li>
    <li>construct</li>
    <li>getPrototypeOf</li>
    <li>setPrototypeOf</li>
    <li>isExtensible</li>
    <li>preventExtensions</li>
    <li>defineProperty</li>
    <li>getOwnPropertDescriptors</li>
    <li>ownKeys</li>
</ul>

<h3>Learning from exercises</h3>
<ul>
    <li>use String(num) instead of num.toString() --> doesn't wor</li>
    <li>use split('') to convert string to char array</li>
    <li>carLot[make] is read/writeable . here make is a variable</li>
    <li>while using Object.defineProperty , define all prop bcoz by default its writable : false</li>
    <li>String.fromCharCode(ascii_code) to convert ascii to char</li>
    <li>string indexOf to check if something is inside another , for array , use includes</li>
    <li>instead of trying to create json manually , use var obj = {} , obj.abc = ""</li>
    <li>Array(3) creates a blank array of size 3</li>
    <li>arr.concat(arr1) method , concats two arrays but does not modifies arr , it returns the result</li>
    <li>array concat returns [[a,b,c],[1,2,3]]</li>
    <li>const getBudgets = arr => arr.reduce((a,v) => a + v.budget, 0);
    </li>
    <li>+(string) t change to int</li>
    <li>String(i).split("").reverse().join("") reverse a string</li>
    <li>[arr1,arr2] also works to make array of arrays</li>
    <li>arr.flat() same as [].concat(...args)</li>
    <li>arr.map((x) => parseInt(x)) is same as arr.map(Number)</li>
    <li>arr1.every((x, i) => x == arr2[i]) arr.every can take two args </li>
    <li>A".repeat(21)--> "AAAAAAAAAAAAAAAAAAAAA"</li>
    <li>The every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</li>
    <li>need to have hasOwnProperty guard over for-in loop , else prototype will be looped</li>
    <li>arr.reduce reduces arr to a single element</li>
    <p>The first time the callback is called, accumulator and currentValue can be one of two values. If initialValue is provided in the call to reduce(), then accumulator will be equal to initialValue, and currentValue will be equal to the first value in the array. If no initialValue is provided, then accumulator will be equal to the first value in the array, and currentValue will be equal to the second.

        Note: If initialValue is not provided, reduce() will execute the callback function starting at index 1, skipping the first index. If initialValue is provided, it will start at index 0.
        
        If the array is empty and no initialValue is provided, TypeError will be thrown.
        
        If the array only has one element (regardless of position) and no initialValue is provided, or if initialValue is provided but the array is empty, the solo value will be returned without calling callback.</p>
    <li>if we want to convert number to string array use [...(''+n)]</li>    
    <li>instead of string(n) use n+''</li>
    <li>arr.some tests if any function matches a criteria , arr.every tests if all matches a function test</li>
    <li>Flattens out the full array :- arr.flat(Infinity).length;</li>
    <li>to make a regex match greedy use ? at the end , look ahead works as (?=abc) looks for next char but does not include in group </li>
    <li>s.map(x => ({name: x.name, topNote: Math.max(...x.notes, 0)}))  trying to create an object inside map use ( before {</li>
    <li>map((x) => ({[x[0]] : x[1]}) ) ; wrap key in []</li>
    <li>push does not return  array , conat returns added array</li>
    <li>"abcd ".trimEnd() trims special hars at end</li>
    <li>"".replace("","") replaces only first character , to replace all use "".replace(/abc/g,"")</li>
    <li>https://edabit.com/challenge/g2QxB5HCE9hN3PS75</li>
    <li>map.entries() returns mapiterator, this can be used with for/in or Array.From() </li>
    <li>in case of reduces , where you are not able to assign anything to accumulator , return it </li>
    <li>to check if gcd is 1 or not loop and check if same number divides each</li>
    <li>to find if there are duplicates  c.reduce((x, y) => x.add(y), new Set()).size == c.length</li>
    <li>from set to array use array.from , remove single element from anonymous array use ([].slice(1)).array method</li>
    <li>const countTrue = r => r.filter(Boolean).length this returns all true in array</li>
    <li>string is array like , can convert to Arrayusing split also enter into Set(arraylike) </li>
    <li>new function() creates an object , attaches prop to it , returns this back . When in obj , this rfeers to obj when without it , it refers to global variable </li>
</ul>
    
    <h4>Browser environment, specs</h4>
    <img src="https://javascript.info/article/browser-environment/windowObjects.svg"/>
    <p>BOM : -browser object model , describes set of APIs other than DOM .Actuall specification is different for each api</p>
    <p>There are only two top-level exclusions:

Spaces and newlines before <head> are ignored for historical reasons.
If we put something after body, then that is automatically moved inside the body, at the end, as the HTML spec requires that all content must be inside <body>. So there canâ€™t be any spaces afterbody. </p>
    
        <p> autocorrection is automaticlly doen by browsers . If the browser encounters malformed HTML, it automatically corrects it when making the DOM.</p>
        <p> there are 12 node types :- text , element , comment , document -entry point are a few of them  </p>
        <p> The childNodes collection lists all child nodes, including text nodes. document.body.childNodes[i]. Properties firstChild and lastChild give fast access to the first and last children. </p>
        <p> document.body.childNodes is iterable , hence for of can be used but not array object , call Array.From to create Array , DOM collections are read only . all DOM collections are live . Please, donâ€™t. The for..in loop iterates over all enumerable properties. And collections have some â€œextraâ€ rarely used properties that we usually do not want to get:</p>
        <p><html> = document.documentElement is root element </p>
        <p> <body> = document.body  , <head> = document.head  . While walking the DOM , there maybe a chance that  body is not yet available . , when file is being read from top to bottom</p>
        <p> The childNodes collection lists all child nodes, including text nodes. descendants are all deeply nested elements ,document.body.childNodes will print all child nodes just before this line </p>
       <p>document.body.childNodes , Properties firstChild and lastChild give fast access to the first and last children.As we can see, childNodes looks like an array. But actually itâ€™s not an array, but rather a collection â€“ a special array-like iterable object.</p>
            <p> Siblings , nextSibling , previousSibling , parentNode , </p>
            <p> element only property . The links are similar to those given above, just with Element word inside:

children â€“ only those children that are element nodes.
firstElementChild, lastElementChild â€“ first and last element children.
previousElementSibling, nextElementSibling â€“ neighbor elements.
parentElement â€“ parent element.</p>
            <p> why parentElement return an element but parentNode returns any node :- The reason is that the root node document.documentElement (<html>) has document as its parent. But document is not an element node, so parentNode returns it and parentElement does not.</p>
                
            <img src="https://javascript.info//article/dom-navigation/dom-links-elements.svg" />
                
            <p>Till now we described the basic navigation properties.

Certain types of DOM elements may provide additional properties, specific to their type, for convenience.

Tables are a great example of that, and represent a particularly important case:

The <table> element supports (in addition to the given above) these properties:

table.rows â€“ the collection of <tr> elements of the table.
table.caption/tHead/tFoot â€“ references to elements <caption>, <thead>, <tfoot>.
table.tBodies â€“ the collection of <tbody> elements (can be many according to the standard, but there will always be at least one â€“ even if it is not in the source HTML, the browser will put it in the DOM).
<thead>, <tfoot>, <tbody> elements provide the rows property:

tbody.rows â€“ the collection of <tr> inside.
<tr>:

tr.cells â€“ the collection of td and th cells inside the given <tr>.
tr.sectionRowIndex â€“ the position (index) of the given <tr> inside the enclosing <thead>/<tbody>/<tfoot>.
tr.rowIndex â€“ the number of the tr in the table as a whole (including all table rows).
td and th:

td.cellIndex â€“ the number of the cell inside the enclosing tr.</p>
            <p> getElement*, querySelector* </p>    
            <p>If an element has the id attribute, we can get the element using the method document.getElementById(id), no matter where it is. Also, thereâ€™s a global variable named by id that references the element:
example :-
                <code>
                    <div id="elem">
  <div id="elem-content">Element</div>
</div>
                    
                    we can use elem.style.background = 'red'; or window[elem-content] , unless there is a global js variable with same name
                    </code>
                
                
 </p>
            
            <p> The id must be unique. There can be only one element in the document with the given id.

If there are multiple elements with the same id, then the behavior of methods that use it is unpredictable, e.g. document.getElementById may return any of such elements at random. So please stick to the rule and keep id unique. </p>
            <p> Only document.getElementById, not anyElem.getElementById </p>
            <p> By far, the most versatile method, elem.querySelectorAll(css) returns all elements inside elem matching the given CSS selecto . Pseudo-classes in the CSS selector like :hover and :active are also supported. For instance, document.querySelectorAll(':hover') will return the collection with elements that the pointer is over now (in nesting order: from the outermost <html> to the most nested one).</p>
            <p> querySelector
The call to elem.querySelector(css) returns the first element for the given CSS selector.

In other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So itâ€™s faster and also shorter to write.</p>                
            <p> querySelector
The call to elem.querySelector(css) returns the first element for the given CSS selector.

In other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So itâ€™s faster and also shorter to write. </p>
            <p>The elem.matches(css) does not look for anything, it merely checks if elem matches the given CSS-selector. It returns true or false.</p>
            <p>closest
Ancestors of an element are: parent, the parent of parent, its parent and so on. The ancestors together form the chain of parents from the element to the top.

The method elem.closest(css) looks for the nearest ancestor that matches the CSS-selector. The elem itself is also included in the search.

In other words, the method closest goes up from the element and checks each of parents. If it matches the selector, then the search stops, and the ancestor is returned. </p>
            
            <p>getelementsby* returns live collection while queryselectors returns static collection , we couls also use elemA.contains(elemB)</p>
            <table>
<thead>
<tr>
<td>Method</td>
<td>Searches by...</td>
<td>Can call on an element?</td>
<td>Live?</td>
</tr>
</thead>
<tbody>
<tr>
<td><code>querySelector</code></td>
<td>CSS-selector</td>
<td>âœ”</td>
<td>-</td>
</tr>
<tr>
<td><code>querySelectorAll</code></td>
<td>CSS-selector</td>
<td>âœ”</td>
<td>-</td>
</tr>
<tr>
<td><code>getElementById</code></td>
<td><code>id</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>getElementsByName</code></td>
<td><code>name</code></td>
<td>-</td>
<td>âœ”</td>
</tr>
<tr>
<td><code>getElementsByTagName</code></td>
<td>tag or <code>'*'</code></td>
<td>âœ”</td>
<td>âœ”</td>
</tr>
<tr>
<td><code>getElementsByClassName</code></td>
<td>class</td>
<td>âœ”</td>
<td>âœ”</td>
</tr>
</tbody>
</table>
            
            
            <h4>Node properties: type, tag and contents</h4>
            <img src="https://javascript.info/article/basic-dom-node-properties/dom-class-hierarchy.svg" />
            <p>The classes are:

EventTarget â€“ is the root â€œabstractâ€ class. Objects of that class are never created. It serves as a base, so that all DOM nodes support so-called â€œeventsâ€, weâ€™ll study them later.
Node â€“ is also an â€œabstractâ€ class, serving as a base for DOM nodes. It provides the core tree functionality: parentNode, nextSibling, childNodes and so on (they are getters). Objects of Node class are never created. But there are concrete node classes that inherit from it, namely: Text for text nodes, Element for element nodes and more exotic ones like Comment for comment nodes.
Element â€“ is a base class for DOM elements. It provides element-level navigation like nextElementSibling, children and searching methods like getElementsByTagName, querySelector. A browser supports not only HTML, but also XML and SVG. The Element class serves as a base for more specific classes: SVGElement, XMLElement and HTMLElement.
HTMLElement â€“ is finally the basic class for all HTML elements. It is inherited by concrete HTML elements:
HTMLInputElement â€“ the class for <input> elements,
HTMLBodyElement â€“ the class for <body> elements,
HTMLAnchorElement â€“ the class for <a> elements,
â€¦and so on, each tag has its own class that may provide specific properties and methods.</p>
                <h4>The â€œnodeTypeâ€ property</h4>
                <p>The nodeType property provides one more, â€œold-fashionedâ€ way to get the â€œtypeâ€ of a DOM node.

It has a numeric value:

elem.nodeType == 1 for element nodes,
elem.nodeType == 3 for text nodes,
elem.nodeType == 9 for the document object,
there are few other values in the specification.</p>
                <h4>Tag: nodeName and tagName</h4>
                <p>Sure, the difference is reflected in their names, but is indeed a bit subtle.

The tagName property exists only for Element nodes.
The nodeName is defined for any Node:
for elements it means the same as tagName.
for other node types (text, comment, etc.) it has a string with the node type.</p>
                <p>In other words, tagName is only supported by element nodes (as it originates from Element class), while nodeName can say something about other node types.
              
For instance, letâ€™s compare tagName and nodeName for the document and a comment node:</p>
                 <h4>innerHTML: the contents</h4>
                <p>We can try to insert invalid HTML, the browser will fix our errors: If innerHTML inserts a script tag into the document â€“ it becomes a part of HTML, but doesnâ€™t execute.</p>
                <p>As the content is â€œzeroed-outâ€ and rewritten from the scratch, all images and other resources will be reloaded.

In the chatDiv example above the line chatDiv.innerHTML+="How goes?" re-creates the HTML content and reloads smile.gif (hope itâ€™s cached). If chatDiv has a lot of other text and images, then the reload becomes clearly visible.

There are other side-effects as well. For instance, if the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting innerHTML. And if there was an <input> with a text entered by the visitor, then the text will be removed. And so on.</p>
                <h4>outerHTML: full HTML of the element</h4>                
                <p>The outerHTML property contains the full HTML of the element. Thatâ€™s like innerHTML plus the element itself.Beware: unlike innerHTML, writing to outerHTML does not change the element. Instead, it replaces it in the DOM.</p>
                <code> let div = document.querySelector('div');

  // replace div.outerHTML with <p>...</p>
  div.outerHTML = '<p>A new element</p>'; // (*)

  // Wow! 'div' is still the same!
  alert(div.outerHTML); // <div>Hello, world!</div> (**)</code>
                <p>nodeValue/data: text node content
The innerHTML property is only valid for element nodes.

Other node types, such as text nodes, have their counterpart: nodeValue and data properties. These two are almost the same for practical use, there are only minor specification differences. So weâ€™ll use data, because itâ€™s shorter.</p>
                <p>textContent: pure text
The textContent provides access to the text inside the element: only text, minus all <tags>.</p>
                <p>Writing to textContent is much more useful, because it allows to write text the â€œsafe wayâ€.

Letâ€™s say we have an arbitrary string, for instance entered by a user, and want to show it.

With innerHTML weâ€™ll have it inserted â€œas HTMLâ€, with all HTML tags.
With textContent weâ€™ll have it inserted â€œas textâ€, all symbols are treated literally.</p>
                <p>More properties
DOM elements also have additional properties, in particular those that depend on the class:

value â€“ the value for input, select and textarea (HTMLInputElement, HTMLSelectElementâ€¦).
href â€“ the â€œhrefâ€ for a href="..." (HTMLAnchorElement).
id â€“ the value of â€œidâ€ attribute, for all elements (HTMLElement).</p>
                    <p>The â€œhiddenâ€ property
The â€œhiddenâ€ attribute and the DOM property specifies whether the element is visible or not.

We can use it in HTML or assign it using JavaScript, like this:</p>
                    <p> div hidden>With the attribute "hidden"/div this element will be hidden</p>
                    
                    
So, DOM properties and methods behave just like those of regular JavaScript objects:

They can have any value.
They are case-sensitive (write elem.nodeType, not elem.NoDeTyPe).
                <h2>Attributes and prop</h2>
DOM props vs Attributes :-
                    DOM nodes are regular js objects . We can add out own methods if not provided as stabdard `document.body.sayTagName()`
                    We can modify all element objects using Elements.prototype and add new methods 
                    DOM props behave like regular js :- can have any values and are case sensitive
                    
                    For standard HTML attributes , it gets parsed and DOM properties are created
                    but does not happen for non standard attribute :- 
                    so document.body.id works but not document.body.something , if we want to access non standard attributes we use :-
                     All attributes are accessible by using the following methods:

elem.hasAttribute(name) â€“ checks for existence.
elem.getAttribute(name) â€“ gets the value.
elem.setAttribute(name, value) â€“ sets the value.
elem.removeAttribute(name) â€“ removes the attribute.
These methods operate exactly with whatâ€™s written in HTML.
                    
                    we can also use elem.attributes: a collection of objects that belong to a built-in Attr class, with name and value properties. 
                    HTML attributes have the following features:

Their name is case-insensitive (id is same as ID).
Their values are always strings.
                    
                <h2>Property-attribute synchronization</h2>
                    
                    When a standard attribute changes, the corresponding property is auto-updated, and (with some exceptions) vice versa.

                    But there are exclusions, for instance input.value synchronizes only from attribute â†’ to property, but not back:
                    
                <h2>DOM properties are typed</h2>
                    
                    example :- input.checked 
                    we can use non standard attribute for styling  .order[order-state="new"] {
    color: green;
  }
can be prefferd than class as its easier than to addclass removeclass etc.  
                    
                    
All attributes starting with â€œdata-â€ are reserved for programmersâ€™ use. They are available in the dataset property.
                    

For instance, if an elem has an attribute named "data-about", itâ€™s available as elem.dataset.about.
                    Multiword attributes like data-order-state become camel-cased: dataset.orderState.
                    
                    we can update as well order.dataset.orderState = "pending"
                    
                    <h2>Modifying the document</h2>
                    
                    Creating an element
To create DOM nodes, there are two methods:

                    <code>document.createElement(tag)</code> , create text node as <code>document.createTextNode(text)</code>
                    
                    <h2>Insertion methods</h2>
                    
                    we can use document.body.append(div).
                    
                    Here are more insertion methods, they specify different places where to insert:

node.append(...nodes or strings) â€“ append nodes or strings at the end of node,
node.prepend(...nodes or strings) â€“ insert nodes or strings at the beginning of node,
node.before(...nodes or strings) â€“- insert nodes or strings before node,
node.after(...nodes or strings) â€“- insert nodes or strings after node,
node.replaceWith(...nodes or strings) â€“- replaces node with the given nodes or strings.
                    
                    <h2>insert html :-</h2>
                    insertAdjacentHTML/Text/Element
                    
                    The first parameter is a code word, specifying where to insert relative to elem. Must be one of the following:

"beforebegin" â€“ insert html immediately before elem,
"afterbegin" â€“ insert html into elem, at the beginning,
"beforeend" â€“ insert html into elem, at the end,
"afterend" â€“ insert html immediately after elem.
The second parameter is an HTML string, that is inserted â€œas HTMLâ€.
                    
                    so syntax is this :- 
                    The method has two brothers:

elem.insertAdjacentText(where, text) â€“ the same syntax, but a string of text is inserted â€œas textâ€ instead of HTML,
elem.insertAdjacentElement(where, elem) â€“ the same syntax, but inserts an element.
                    
                    <h2>Node removal</h2>
                    <p>node.remove().</p>
                    Please note: if we want to move an element to another place â€“ thereâ€™s no need to remove it from the old one.

All insertion methods automatically remove the node from the old place.
                    
                    <h2> Cloning nodes: cloneNode</h2>
                    The call elem.cloneNode(true) creates a â€œdeepâ€ clone of the element â€“ with all attributes and subelements. If we call elem.cloneNode(false), then the clone is made without child elements.
                    
                    DocumentFragment
DocumentFragment is a special DOM node that serves as a wrapper to pass around lists of nodes.
                     let fragment = new DocumentFragment();
                    <h2>old school ways to alter DOM</h2>
                    parentElem.appendChild(node) , parentElem.insertBefore(node, nextSibling) , parentElem.replaceChild(node, oldChild) , parentElem.removeChild(node)
                    
                    today we can use 
                    <ul>
                        <li>append, prepend, before, after, remove, replaceWith</li>
                    </ul>
                    
                    The call to document.write(html) writes the html into page â€œright here and nowâ€. The call to document.write only works while the page is loading.
                    If we call it afterwards, the existing document content is erased.
                    
                    
                    <h2>className and classList</h2>
                    we can use class attribute or className prop
                    Thereâ€™s another property for that: elem.classList.

The elem.classList is a special object with methods to add/remove/toggle a single class.
                    
                    Methods of classList:

elem.classList.add/remove("class") â€“ adds/removes the class.
elem.classList.toggle("class") â€“ adds the class if it doesnâ€™t exist, otherwise removes it.
elem.classList.contains("class") â€“ checks for the given class, returns true/false.
                    element.style gets sets the valuw of style
                    
                    If we set style.display to an empty string, then the browser applies CSS classes and its built-in styles normally, as if there were no such style.display property at all.
                    we cant set the full style 
                    We canâ€™t set the full style like div.style="color: red; width: 100px", because div.style is an object, and itâ€™s read-only.
                    Browser-prefixed properties like -moz-border-radius, -webkit-border-radius also follow the same rule: a dash means upper case.

For instance:

button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
                    to set styles use :- 
                    div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `;
this can also be used for div.setAttribute('style', 'color: red...').
                    
                    
                    Computed styles: getComputedStyle
                    
                    The style property operates only on the value of the "style" attribute, without any CSS cascade.

So we canâ€™t read anything that comes from CSS classes using elem.style. alert(document.body.style.color); // empty
    alert(document.body.style.marginTop); // empty 
                    
                    to read and manipulate on exisiting values use :- getComputedStyle(element, [pseudo]) psuedo is optional 
                    
                    let computedStyle = getComputedStyle(document.body);

    // now we can read the margin and the color from it

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
                    
                    computedstyle vs resolvedstyle:-
                    it is same today except few styles 
                    
                    styles applied to :visited css are hidden for security purpose , use full prop name in getcomputedstylename 
                    
                    <h2>element style and scrolling</h2>
                    
                    <img src="https://javascript.info/article/size-and-scroll/metric-css.svg" />
                    <img src="https://javascript.info/article/size-and-scroll/metric-all.svg" />
                    
                    The offsetParent is the nearest ancestor that the browser uses for calculating coordinates during rendering.

Thatâ€™s the nearest ancestor that is one of the following:

CSS-positioned (position is absolute, relative, fixed or sticky), or
td, th, or table, or
body.
                    
                    There are several occasions when offsetParent is null:

For not shown elements (display:none or not in the document).
For <body> and <html>.
For elements with position:fixed.
                    
                    Geometry properties are zero/null for elements that are not displayed
                     relative coordinates of the inner side from the outer side.
                    
                    offsetwidth /height provides the outer width and height or element
                    
                    clienttop/left :- â€¦But to be precise â€“ these properties are not border width/height, but rather relative coordinates of the inner side from the outer side.
                    <img src="https://javascript.info/article/size-and-scroll/metric-client-left-top-rtl.svg" />
                    
                    These properties provide the size of the area inside the element borders.

They include the content width together with paddings, but without the scrollbar:


                    scrollLeft/scrollTop
Properties scrollLeft/scrollTop are the width/height of the hidden, scrolled out part of the element.
                    
                    Most of the geometry properties here are read-only, but scrollLeft/scrollTop can be changed, and the browser will scroll the element.

If you click the element below, the code elem.scrollTop += 10 executes. That makes the element content scroll 10px down.
                    
                    dont read any of these props from getcomputed styles method :- as it will give auto in many cases and not exact pixel 
                    
                    Summary
Elements have the following geometry properties:

offsetParent â€“ is the nearest positioned ancestor or td, th, table, body.
offsetLeft/offsetTop â€“ coordinates relative to the upper-left edge of offsetParent.
offsetWidth/offsetHeight â€“ â€œouterâ€ width/height of an element including borders.
clientLeft/clientTop â€“ the distances from the upper-left outer corner to the upper-left inner (content + padding) corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so clientLeft includes its width too.
clientWidth/clientHeight â€“ the width/height of the content including paddings, but without the scrollbar.
scrollWidth/scrollHeight â€“ the width/height of the content, just like clientWidth/clientHeight, but also include scrolled-out, invisible part of the element.
scrollLeft/scrollTop â€“ width/height of the scrolled out upper part of the element, starting from its upper-left corner.
                    
                    
                    <h2> width and height of window</h2>
                    To get window width and height, we can use the clientWidth/clientHeight of document.documentElement:
                    
                    To reliably obtain the full document height, we should take the maximum of these properties:

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);
                    
                    // no reason why , just these are legacy nuances
                    
                    DOM elements have their current scroll state in their scrollLeft/scrollTop properties.
                    
                    Luckily, we donâ€™t have to remember these peculiarities at all, because the scroll is available in the special properties, window.pageXOffset/pageYOffset:

These properties are read-only.
                    
                    Alternatively, thereâ€™s a simpler, universal solution: special methods window.scrollBy(x,y) and window.scrollTo(pageX,pageY).

The method scrollBy(x,y) scrolls the page relative to its current position. For instance, scrollBy(0,10) scrolls the page 10px down.
                    
                    
                    The method scrollTo(pageX,pageY) scrolls the page to absolute coordinates, so that the top-left corner of the visible part has coordinates (pageX, pageY) relative to the documentâ€™s top-left corner. Itâ€™s like setting scrollLeft/scrollTop.

To scroll to the very beginning, we can use scrollTo(0,0).


                    
                    scrollIntoView
For completeness, letâ€™s cover one more method: elem.scrollIntoView(top).

The call to elem.scrollIntoView(top) scrolls the page to make elem visible. It has one argument:

If top=true (thatâ€™s the default), then the page will be scrolled to make elem appear on the top of the window. The upper edge of the element will be aligned with the window top.
If top=false, then the page scrolls to make elem appear at the bottom. The bottom edge of the element will be aligned with the window bottom.
                    
                    
                    <h4> Forbid the scrolling</h4>
Sometimes we need to make the document â€œunscrollableâ€. For instance, when we need to cover the page with a large message requiring immediate attention, and we want the visitor to interact with that message, not with the document.

To make the document unscrollable, itâ€™s enough to set document.body.style.overflow = "hidden". The page will â€œfreezeâ€ at its current scroll position.

Try it:

document.body.style.overflow = â€˜hiddenâ€™

document.body.style.overflow = â€˜â€™

The first button freezes the scroll, while the second one releases it.

We can use the same technique to freeze the scroll for other elements, not just for document.body.

The drawback of the method is that the scrollbar disappears. If it occupied some space, then that space is now free and the content â€œjumpsâ€ to fill it.

That looks a bit odd, but can be worked around if we compare clientWidth before and after the freeze. If it increased (the scrollbar disappeared), then add padding to document.body in place of the scrollbar to keep the content width the same.
                    
                    <h2>coordinates</h2>
                    
    most coordinate systems work with one of two coordinate system :-
                    Relative to the window 
                    Relative to the document 
                    
                    The method elem.getBoundingClientRect() returns window coordinates for a minimal rectangle that encloses elem as an object of built-in DOMRect class.
                    Main DOMRect properties:

x/y â€“ X/Y-coordinates of the rectangle origin relative to window,
width/height â€“ width/height of the rectangle (can be negative).
Additionally, there are derived properties:

top/bottom â€“ Y-coordinate for the top/bottom rectangle edge,
left/right â€“ X-coordinate for the left/right rectangle edge.
                    
                    elementFromPoint(x, y)
The call to document.elementFromPoint(x, y) returns the most nested element at window coordinates (x, y).

The syntax is:

let elem = document.elementFromPoint(x, y);
                    
                    Any point on the page has coordinates:

Relative to the window â€“ elem.getBoundingClientRect().
Relative to the document â€“ elem.getBoundingClientRect() plus the current page scroll.
Window coordinates are great to use with position:fixed, and document coordinates do well with position:absolute.

Both coordinate systems have their pros and cons; there are times we need one or the other one, just like CSS position absolute and fixed.
                    
                    
    
                    
                    
                    
</body>
<head>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script
    src="https://code.jquery.com/jquery-3.4.1.min.js"
    integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
    crossorigin="anonymous"></script>
   <script>

       function calc()
       {
           var element = event.target;
           var snippet = Array.from( $(element)[0].parentElement.children).find((x) => x.className == '1c').textContent 
            Array.from( $(element)[0].parentElement.children).find((x) => x.className == '1a').textContent = eval(snippet)
           
       }
       
      
           

    </script>
    <style>
    code {
        display: block;
        white-space: pre-wrap   
        }

    .codeblock
    {
        background-color: bisque;
        border-radius: 4px;
        margin-left: 10px;
        margin-right: 10px;
    }
    body{
        margin-left: 20px;
        background-color: grey;
    }
p , li{
    color: white;
}
    .btn
    {
        margin-left: 5px;
        margin-bottom: 5px;
        
    }

    table tr td{
        border-width: 2px;border-style: solid;border-color: black;
    }
    </style>
</head>
</html>
